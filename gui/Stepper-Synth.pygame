#!/usr/bin/python
import pygame
from pygame.rect import Rect
from stepper_synth_backend import start_audio as start_synth, PythonCmd, State, SynthEngineType
from pathlib import Path
from logging import DEBUG, INFO
# from stepper_synth.synth_state import SynthState
from stepper_synth.config import *
from stepper_synth.organ_screen import draw_organ
from stepper_synth.controls import buttons, Buttons
from stepper_synth.logger import get_logger
# import stepper_synth
#
# print(dir(stepper_synth))
# print(stepper_synth.__path__)
# print(stepper_synth_helpers.__file__)


THIS_DIR = Path(__file__)
THIS_DIR = THIS_DIR.parent.absolute()
# print("this dir: ", THIS_DIR)

pygame.init()
# pygame.joystick.init()
controller_found = False
joy = None
screen = pygame.display.set_mode(SCREEN_SIZE)
pygame.font.init()
fonts = [pygame.font.Font(f'{THIS_DIR}/Anonymous-Pro.ttf', 45),
         pygame.font.Font(f'{THIS_DIR}/Anonymous-Pro.ttf', 30)]
clock = pygame.time.Clock()
done = False
log = get_logger("MIDI-Tracker", DEBUG)
controller = Buttons()

ipc, state = start_synth()


def clear_screen():
    # screen.fill((30, 30, 46))
    screen.fill(BACKGROUND_COLOR)


def draw_text(text):
    arg = text.text
    font = fonts[0]
    color = text.color
    display = font.render(
        arg, True, color)
    textRect = display.get_rect()

    x, y = text.ancor

    textRect.center = (x, y)

    if not text.center:
        textRect.left = x

    screen.blit(display, textRect)


def draw_rect(rect_cmd):
    # arg = text.text
    # font = fonts[0]
    color = rect_cmd.fill_color
    # display = font.render(
    #     arg, True, color)
    # textRect = display.get_rect()

    # x, y = text.ancor

    # textRect.center = (x, y)
    (left, top) = rect_cmd.ancor
    (width, height) = rect_cmd.size

    rect = Rect((top, left), (width, height))

    if rect_cmd.center:
        rect.center = (left, top)

    # print(f"drawing rect => Rect(({top}, {left}), ({width}, {height}))")

    pygame.draw.rect(screen, color, rect)

    # screen.blit(display, textRect)


def check_controller_input(event):
    global controller

    if event.type == pygame.JOYHATMOTION:
        controller.purge_dpad()

        match event.value:
            case (_, 1):
                controller.press((0, 1))
            case (_, -1):
                controller.press((0, -1))

        match event.value:
            case (1, _):
                controller.press((1, 0))
            case (-1, _):
                controller.press((-1, 0))

    elif event.type == pygame.JOYBUTTONUP:
        controller.release(event.button)
    elif event.type == pygame.JOYBUTTONDOWN:
        controller.press(event.button)
    elif event.type == pygame.JOYAXISMOTION and event.axis == 4 and event.value > 0.0:
        controller.press(buttons.get("lt"))
        # tracker_ipc.send(InputCMD.ButtonPress(Button.LTrig))
    elif event.type == pygame.JOYAXISMOTION and event.axis == 5 and event.value > 0.0:
        controller.press(buttons.get("rt"))
    elif event.type == pygame.JOYAXISMOTION and event.axis == 4 and event.value < 0.0:
        controller.press(buttons.get("lt"))
        # tracker_ipc.send(InputCMD.ButtonPress(Button.LTrig))
    elif event.type == pygame.JOYAXISMOTION and event.axis == 5 and event.value < 0.0:
        controller.press(buttons.get("rt"))

    # if event.type == pygame.JOYAXISMOTION and (event.axis == 5 or event.axis == 4):
    #     print(f"button-event: {event}")
    # pass


def handle_pygame_events():
    global joy
    global controller_found

    for event in pygame.event.get():
        if event.type == pygame.QUIT or (event.type == pygame.JOYBUTTONUP and event.button == 8):
            log.warning("QUIT")
            ipc.send(PythonCmd.Exit())
            pygame.quit()
            return True
        elif event.type == pygame.JOYDEVICEADDED:
            joy = pygame.joystick.Joystick(event.device_index)
            controller_found = True

        if controller_found:
            check_controller_input(event)

    return False


def draw(synth_state: State):
    """draws the synth ui to the screen"""
    # print(dir(synth_state))

    match synth_state.engine:
        case SynthEngineType.B3Organ:
            draw_organ(pygame, screen, synth_state)

    # TODO: draw volume & battery


def proccess_cmd():
    global state

    new_state = ipc.recv()

    if new_state:
        draw(new_state)
        state = new_state
    else:
        draw(state)

    pygame.display.update()


def loop_clean_up():
    global controller

    controller.step()
    clock.tick()


def step():
    clear_screen()


if __name__ == "__main__":
    while not handle_pygame_events():
        proccess_cmd()
        step()
        loop_clean_up()

    log.warning("DONE")
    quit()
